## 第 4 章 NumPy 基础：数组和向量计算

### NumPy 的部分功能如下
ndarray，一个具有向量算术运算和复杂广播能力的快速且节省空间的多维数组。
#### 用于对整组数据进行快速运算的标准数学函数（无需编写循环）。
#### 用于读写磁盘数据的工具以及用于操作内存映射文件的工具。
#### 线性代数、随机数生成以及傅里叶变换功能。
用于集成由 C、C++、Fortran 等语言编写的代码的 C API
NumPy 本身并没有提供多么高级的数据分析功能，理解 NumPy 数组以及面向数组的计算将有助于你更加高效地使用诸如 pandas 之类的工具
对于大部分数据分析应用而言，我最关注的功能主要集中在：

1.用于数据整理和清理、子集构造和过滤、转换等快速的向量化数组运算。

2.常用的数组算法，如排序、唯一化、集合运算等。

3.高效的描述统计和数据聚合/摘要运算。

4.用于异构数据集的合并/连接运算的数据对齐和关系型数据运算。

5.将条件逻辑表述为数组表达式（而不是带有if-elif-else分支的循环）。

6.数据的分组运算（聚合、转换、函数应用等

### 虽然 NumPy 提供了通用的数值数据处理的计算基础，但大多数读者可能还是想将 pandas 作为统计和分析工作的基础，尤其是处理表格数据时。pandas 还提供了一些 NumPy 所没有的领域特定的功能，如时间序列处理等

NumPy 可以在整个数组上执行复杂的计算，而不需要 Python 的for循环
基于 NumPy 的算法要比纯 Python 快 10 到 100 倍（甚至更快），并且使用的内存更少

### NumPy 的ndarray：一种多维数组对象


```python
#NumPy 最重要的一个特点就是其 N 维数组对象（即ndarray），
# 该对象是一个快速而灵活的大数据集容器。
# 你可以利用这种数组对整块数据执行一些数学运算，其语法跟标量元素之间的运算一样
import numpy as np
data=np.random.randn(2,3) #randn函数返回一个或一组样本，具有标准正态分布
type(data) #ndarray N维数组对象
data
```




    array([[ 1.25742356,  0.9739485 , -2.05407486],
           [ 1.02087757, -0.31137778,  0.68878369]])




```python
#进行数学运算
data *2 #所有元素都*2
data+data #每个元素都与自身相加
```




    array([[ 2.51484712,  1.94789699, -4.10814972],
           [ 2.04175515, -0.62275556,  1.37756738]])




```python
# ndarray是一个通用的同构数据多维容器，也就是说，其中的所有元素必须是相同类型的。每个数组都有一个shape
# （一个表示各维度大小的元组）和一个dtype（一个用于说明数组数据类型的对象）：
# 创建数组最简单的办法就是使用array函数。它接受一切序列型的对象（包括其他数组），
# 然后产生一个新的含有传入数据的 NumPy 数组。以一个列表的转换为例
import numpy as np
data1 = [6, 7.5, 8, 0, 1]
arr1 = np.array(data1)
type(arr1)

```




    numpy.ndarray




```python
#嵌套序列（比如由一组等长列表组成的列表）将会被转换为一个多维数组
data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
arr2=np.array(data2)
print(arr2)
print(arr2.shape)
arr2.ndim
```

    [[1 2 3 4]
     [5 6 7 8]]
    (2, 4)





    2



#### 因为data2是列表的列表，NumPy 数组arr2的两个维度的shape是从data2引入的。可以用属性ndim和shape验证


```python
# 除非特别说明（稍后将会详细介绍），np.array会尝试为新建的这个数组推断出一个较为合适的数据类型。
# 数据类型保存在一个特殊的dtype对象中
arr2.dtype
```




    dtype('int64')




```python
# 除np.array之外，还有一些函数也可以新建数组。比如，
# zeros和ones分别可以创建指定长度或形状的全 0 或全 1 数组。
# empty可以创建一个没有任何具体值的数组。
# 要用这些方法创建多维数组，只需传入一个表示形状的元组  如(1，2)
np.zeros(10)
np.zeros((3,4))
```




    array([[0., 0., 0., 0.],
           [0., 0., 0., 0.],
           [0., 0., 0., 0.]])




```python
np.ones(4)
```




    array([1., 1., 1., 1.])




```python
# arange是 Python 内置函数range的数组版
np.arange(10)
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
# ndarray的astype方法明确地将一个数组从一个dtype转换成另一个dtype
arr = np.array([1, 2, 3, 4, 5])
print(arr.dtype)
float_arr=arr.astype(np.float64)
float_arr
# 在本例中，整数被转换成了浮点数。如果将浮点数转换成整数，则小数部分将会被截取删除
# 如果某字符串数组表示的全是数字，也可以用astype将其转换为数值形式
```

    int64





    array([1., 2., 3., 4., 5.])



#### numpy.string_类型时，一定要小心，因为 NumPy 的字符串数据是大小固定的，发生截取时，不会发出警告。pandas 提供了更多非数值数据的便利的处理方法。
##### 如果转换过程因为某种原因而失败了（比如某个不能被转换为float64的字符串），就会引发一个ValueError。这里，我比较懒，写的是float而不是np.float64；NumPy 很聪明，它会将 Python 类型映射到等价的dtype上



```python
numeric_strings = np.array(['1.25', '-9.6', '42'], dtype=np.string_)
numeric_strings.astype(float)
# 调用astype总会创建一个新的数组（一个数据的备份），即使新的dtype与旧的dtype相同
```




    array([ 1.25, -9.6 , 42.  ])



### numpy 数组的运算
数组很重要，因为它使你不用编写循环即可对数据执行批量运算。NumPy 用户称其为向量化（vectorization）。大小相等的数组之间的任何算术运算都会将运算应用到元素级：


```python
arr = np.array([[1., 2., 3.], [4., 5., 6.]])

In [52]: arr
Out[52]: 
array([[ 1.,  2.,  3.],
       [ 4.,  5.,  6.]])

In [53]: arr * arr
Out[53]: 
array([[  1.,   4.,   9.],
       [ 16.,  25.,  36.]])

In [54]: arr - arr
Out[54]: 
array([[ 0.,  0.,  0.],
       [ 0.,  0.,  0.]])

In [55]: 1 / arr
Out[55]: 
array([[ 1.    ,  0.5   ,  0.3333],
       [ 0.25  ,  0.2   ,  0.1667]])

In [56]: arr ** 0.5
Out[56]: 
array([[ 1.    ,  1.4142,  1.7321],
       [ 2.    ,  2.2361,  2.4495]])
```


      File "<ipython-input-43-772066eea2ba>", line 4
        Out[52]:
                 ^
    SyntaxError: invalid syntax




```python
# 大小相同的数组之间的比较会生成布尔值数组
In [57]: arr2 = np.array([[0., 4., 1.], [7., 2., 12.]])

In [58]: arr2
Out[58]: 
array([[  0.,   4.,   1.],
       [  7.,   2.,  12.]])

In [59]: arr2 > arr
Out[59]:
array([[False,  True, False],
       [ True, False,  True]], dtype=bool)
# 不同大小的数组之间的运算叫做广播（broadcasting）
```


      File "<ipython-input-44-82f2e0b42f70>", line 5
        Out[58]:
                 ^
    SyntaxError: invalid syntax



### 基本的索引和切片
NumPy 数组的索引是一个内容丰富的主题，因为选取数据子集或单个元素的方式有很多。一维数组很简单。从表面上看，它们跟 Python 列表的功能差不多


```python
arr=np.arange(10)
print(arr)
arr[5:8]
```

    [0 1 2 3 4 5 6 7 8 9]





    array([5, 6, 7])



### 当你将一个标量值赋值给一个切片时（如arr[5:8]=12），
该值会自动传播（也就说后面将会讲到的“广播”）到整个选区。
## 跟列表最重要的区别在于，数组切片是原始数组的视图。
### 这意味着数据不会被复制，视图上的任何修改都会直接反映到源数组上。


```python
arr = np.arange(10)
arr_slice = arr[5:8]
arr_slice[1] = 12345
arr #修改arr_slice中的值，变动也会体现在原始数组arr中
arr_slice[:] = 64
arr
#由于 NumPy 的设计目的是处理大数据，所以你可以想象一下，
#假如 NumPy 坚持要将数据复制来复制去的话会产生何等的性能和内存问题。
```




    array([ 0,  1,  2,  3,  4, 64, 64, 64,  8,  9])



#### 如果你想要得到的是ndarray切片的一份副本而非视图，就需要明确地进行复制操作


```python
arr[5:8].copy()
```




    array([64, 64, 64])



#### 对于高维度数组，能做的事情更多。在一个二维数组中，各索引位置上的元素不再是标量而是一维数组


```python
arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# 你可以传入一个以逗号隔开的索引列表来选取单个元素。也就是说，下面两种方式是等价的：
arr2d[0][2]
#等价
arr2d[0, 2]
```




    3



### 下图说明了二维数组的索引方式。轴 0 作为行axis=0，轴 1 作为列  axis=1
https://pyda.apachecn.org/docs/img/7178691-0a641536f73f560e.png


```python
# 多维数组中，如果省略了后面的索引，则返回对象会是一个维度低一点的ndarray
#（它含有高一级维度上的所有数据）。因此，在2×2×3数组arr3d中
arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
arr3d[0] # arr3d[0]是一个2×3数组
```




    array([[1, 2, 3],
           [4, 5, 6]])




```python
标量值和数组都可以被赋值给arr3d[0]
In [79]: old_values = arr3d[0].copy()

In [80]: arr3d[0] = 42

In [81]: arr3d
Out[81]: 
array([[[42, 42, 42],
        [42, 42, 42]],
       [[ 7,  8,  9],
        [10, 11, 12]]])

In [82]: arr3d[0] = old_values

In [83]: arr3d
Out[83]: 
array([[[ 1,  2,  3],
        [ 4,  5,  6]],
       [[ 7,  8,  9],
        [10, 11, 12]]])
#在上面所有这些选取数组子集的例子中，返回的数组都是视图。
```


```python
arr3d[1,0]可以访问索引以(1,0)开头的那些值（以一维数组的形式返回）
In [84]: arr3d[1, 0]
Out[84]: array([7, 8, 9])
等价于
In [85]: x = arr3d[1]

In [86]: x
Out[86]: 
array([[ 7,  8,  9],
       [10, 11, 12]])

In [87]: x[0]
Out[87]: array([7, 8, 9])
```

### 切片索引
https://pyda.apachecn.org/docs/img/7178691-9da32d2f4629c304.png


```python
#ndarray的切片语法跟 Python 列表这样的一维对象差不多
#对于之前的二维数组arr2d，其切片方式稍显不同
arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
arr2d[:2]
#它是沿着第 0 轴（即第一个轴）切片的。也就是说，切片是沿着一个轴向选取元素的。
#表达式arr2d[:2]可以被认为是“选取arr2d的前两行
```




    array([[1, 2, 3],
           [4, 5, 6]])




```python
#可以一次传入多个切片，就像传入多个索引那样
arr2d[:2, 1:]
```




    array([[2, 3],
           [5, 6]])




```python
# 注意，“只有冒号”表示选取整个轴，因此你可以像下面这样只对高维轴进行切片
arr2d[:, :1]
```




    array([[1],
           [4],
           [7]])



### 布尔型索引
假设我们有一个用于存储数据的数组以及一个存储姓名的数组（含有重复项）
在这里，我将使用numpy.random中的randn函数生成一些正态分布的随机数据：


```python
data=np.random.randn(7,4)
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
data
```




    array([[-0.98851545, -0.3630074 , -0.9129029 , -0.51148842],
           [-0.92504936,  0.49380296,  0.53523452,  1.11579023],
           [-0.80118561, -1.31476919, -0.25506159, -0.10407805],
           [ 0.95388459,  0.15440652,  0.28419243, -0.27180094],
           [-0.61660051,  0.06058064, -0.7732959 , -0.15283894],
           [ 1.18455456,  1.23899218, -1.11851806,  1.64211213],
           [-1.87168507, -0.19202484, -0.6990057 , -1.77885051]])




```python
# 假设每个名字都对应data数组中的一行，而我们想要选出对应于名字"Bob"的所有行。
# 跟算术运算一样，数组的比较运算（如==）也是向量化的。
# 因此，对names和字符串"Bob"的比较运算将会产生一个布尔型数组：
names == 'Bob'
data[names=='Bob']
```




    array([[-0.98851545, -0.3630074 , -0.9129029 , -0.51148842],
           [ 0.95388459,  0.15440652,  0.28419243, -0.27180094]])



### 布尔型数组的长度必须跟被索引的轴长度一致。此外，还可以将布尔型数组跟切片、整数（或整数序列，稍后将对此进行详细讲解）混合使用：
### 如果布尔型数组的长度不对，布尔型选择就会出错，因此一定要小心
要选择除"Bob"以外的其他值，既可以使用不等于符号（!=），也可以通过~对条件进行否定
### 通过布尔型索引选取数组中的数据，将总是创建数据的副本，即使返回一模一样的数组也是如此。




```python
In [106]: names != 'Bob'
Out[106]: array([False,  True,  True, False,  True,  True,  True], dtype=bool)

In [107]: data[~(names == 'Bob')]
Out[107]:
array([[ 1.0072, -1.2962,  0.275 ,  0.2289],
       [ 1.3529,  0.8864, -2.0016, -0.3718],
       [ 3.2489, -1.0212, -0.5771,  0.1241],
       [ 0.3026,  0.5238,  0.0009,  1.3438],
       [-0.7135, -0.8312, -2.3702, -1.8608]])
```


```python
# 选取这三个名字中的两个需要组合应用多个布尔条件，
# 使用&（和）、|（或）之类的布尔算术运算符即可：
In [110]: mask = (names == 'Bob') | (names == 'Will')

In [111]: mask
Out[111]: array([ True, False,  True,  True,  True, False, False], dtype=bool)

In [112]: data[mask]
Out[112]: 
array([[ 0.0929,  0.2817,  0.769 ,  1.2464],
       [ 1.3529,  0.8864, -2.0016, -0.3718],
       [ 1.669 , -0.4386, -0.5397,  0.477 ],
       [ 3.2489, -1.0212, -0.5771,  0.1241]])
```


```python
#通过布尔型数组设置值是一种经常用到的手段。为了将data中的所有负值都设置为 0
data=np.random.randn(7,4)
print(data)
data[data < 0] = 0

data
```

    [[-1.950683    0.88530012  0.62231194 -1.96920366]
     [ 2.38914926 -1.13154899 -0.22959427 -1.08507382]
     [ 0.07940141  1.44007231  0.24741615 -0.88593637]
     [ 1.38264345 -0.05839278  0.67636641 -0.43807968]
     [ 0.79796032 -1.59442851 -1.97385595  0.52621286]
     [-0.05573653  0.20523655  0.47522778  0.6361323 ]
     [ 0.4953071  -1.51656547 -1.32578439 -0.45081356]]





    array([[0.        , 0.88530012, 0.62231194, 0.        ],
           [2.38914926, 0.        , 0.        , 0.        ],
           [0.07940141, 1.44007231, 0.24741615, 0.        ],
           [1.38264345, 0.        , 0.67636641, 0.        ],
           [0.79796032, 0.        , 0.        , 0.52621286],
           [0.        , 0.20523655, 0.47522778, 0.6361323 ],
           [0.4953071 , 0.        , 0.        , 0.        ]])



### 花式索引
花式索引（Fancy indexing）是一个 NumPy 术语，它指的是利用整数数组进行索引。假设我们有一个8×4数组



```python
arr = np.empty((8, 4))
for i in range(8):
    arr[i] = i
arr
```




    array([[0., 0., 0., 0.],
           [1., 1., 1., 1.],
           [2., 2., 2., 2.],
           [3., 3., 3., 3.],
           [4., 4., 4., 4.],
           [5., 5., 5., 5.],
           [6., 6., 6., 6.],
           [7., 7., 7., 7.]])




```python
# 为了以特定顺序选取行子集，只需传入一个用于指定顺序的整数列表或ndarray即可：
arr[[4,3,0,6]]
```




    array([[16, 17, 18, 19],
           [12, 13, 14, 15],
           [ 0,  1,  2,  3],
           [24, 25, 26, 27]])




```python
#使用负数索引将会从末尾开始选取行：arr[[-3, -5, -7]]
```




    array([[5., 5., 5., 5.],
           [3., 3., 3., 3.],
           [1., 1., 1., 1.]])




```python
#一次传入多个索引数组会有一点特别。它返回的是一个一维数组，其中的元素对应各个索引元组：
arr = np.arange(32).reshape((8, 4))
arr[[1, 5, 7, 2], [0, 3, 1, 2]]
# 最终选出的是元素(1,0)、(5,3)、(7,1)和(2,2)。无论数组是多少维的，花式索引总是一维的
```




    array([ 4, 23, 29, 10])




```python
# 花式索引跟切片不一样，它总是将数据复制到新数组中。
In [125]: arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]]
Out[125]: 
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])
```

### 数组转置和轴兑换
转置是重塑的一种特殊形式，它返回的是源数据的视图（不会进行任何复制操作）。数组不仅有transpose方法，还有一个特殊的T属性


```python
arr = np.arange(15).reshape((3, 5))
arr
```




    array([[ 0,  1,  2,  3,  4],
           [ 5,  6,  7,  8,  9],
           [10, 11, 12, 13, 14]])




```python
arr.T
```




    array([[ 0,  5, 10],
           [ 1,  6, 11],
           [ 2,  7, 12],
           [ 3,  8, 13],
           [ 4,  9, 14]])




```python
arr_1=np.arange(6).reshape(2,3)
arr_1
```




    array([[0, 1, 2],
           [3, 4, 5]])




```python
arr_1.T
```




    array([[0, 3],
           [1, 4],
           [2, 5]])




```python
np.dot(arr_1,arr_1.T)
# dot矩阵内积
```




    array([[ 5, 14],
           [14, 50]])



### 通用函数：快速的元素级数组函数
通用函数（即ufunc）是一种对ndarray中的数据执行元素级运算的函数。
你可以将其看做简单函数（接受一个或多个标量值，并产生一个或多个标量值）的向量化包装器


```python
arr=np.arange(10)
arr
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




```python
np.sqrt(arr)
```




    array([0.        , 1.        , 1.41421356, 1.73205081, 2.        ,
           2.23606798, 2.44948974, 2.64575131, 2.82842712, 3.        ])




```python
np.exp(arr)
```




    array([1.00000000e+00, 2.71828183e+00, 7.38905610e+00, 2.00855369e+01,
           5.45981500e+01, 1.48413159e+02, 4.03428793e+02, 1.09663316e+03,
           2.98095799e+03, 8.10308393e+03])




```python
# 这些都是一元（unary）ufunc 另外一些（如add或maximum）接受 2 个数组（因此也叫二元（binary）ufunc），并返回一个结果数组：
In [141]: x = np.random.randn(8)

In [142]: y = np.random.randn(8)

In [143]: x
Out[143]: 
array([-0.0119,  1.0048,  1.3272, -0.9193, -1.5491,  0.0222,  0.7584,
       -0.6605])

In [144]: y
Out[144]: 
array([ 0.8626, -0.01  ,  0.05  ,  0.6702,  0.853 , -0.9559, -0.0235,
       -2.3042])

In [145]: np.maximum(x, y)
Out[145]: 
array([ 0.8626,  1.0048,  1.3272,  0.6702,  0.853 ,  0.0222,  0.7584,   
       -0.6605])
```


```python
# modf就是一个例子，它是 Python 内置函数divmod的向量化版本，它会返回浮点数数组的小数和整数部分：
arr=np.random.randn(7)*5
reminder,whole_part=np.modf(arr)
reminder,whole_part
#Ufuncs可以接受一个out可选参数，这样就能在数组原地进行操作：
```




    (array([ 0.60330301, -0.44880529,  0.68348536, -0.39071881, -0.11571275,
            -0.38568281, -0.5216944 ]),
     array([ 4., -2.,  3., -4., -9., -4., -0.]))



### 返回原数组视图和副本的常见操作：
视图：赋值引用，Numpy 的切片操作，调用view()函数，调用reshape()函数；

副本：Fancy Indexing（花式索引，例如a[[1, 2]]），调用copy()函数；

不能通过id()函数来区分视图和副本

### 利用数组进行数据处理
#### NumPy 数组使你可以将许多种数据处理任务表述为简洁的数组表达式（否则需要编写循环）。用数组表达式代替循环的做法，通常被称为向量化。一般来说，向量化数组运算要比等价的纯 Python 方式快上一两个数量级（甚至更多），尤其是各种数值计算
https://blog.csdn.net/lllxxq141592654/article/details/81532855


```python
# 假设我们想要在一组值（网格型）上计算函数sqrt(x^2+y^2)。
# np.meshgrid函数接受两个一维数组，并产生两个二维矩阵（对应于两个数组中所有的(x,y)对）
points = np.arange(-5, 5, 0.1)
xs,ys=np.meshgrid(points,points)
xs,ys
```




    (array([[-5. , -4.9, -4.8, ...,  4.7,  4.8,  4.9],
            [-5. , -4.9, -4.8, ...,  4.7,  4.8,  4.9],
            [-5. , -4.9, -4.8, ...,  4.7,  4.8,  4.9],
            ...,
            [-5. , -4.9, -4.8, ...,  4.7,  4.8,  4.9],
            [-5. , -4.9, -4.8, ...,  4.7,  4.8,  4.9],
            [-5. , -4.9, -4.8, ...,  4.7,  4.8,  4.9]]),
     array([[-5. , -5. , -5. , ..., -5. , -5. , -5. ],
            [-4.9, -4.9, -4.9, ..., -4.9, -4.9, -4.9],
            [-4.8, -4.8, -4.8, ..., -4.8, -4.8, -4.8],
            ...,
            [ 4.7,  4.7,  4.7, ...,  4.7,  4.7,  4.7],
            [ 4.8,  4.8,  4.8, ...,  4.8,  4.8,  4.8],
            [ 4.9,  4.9,  4.9, ...,  4.9,  4.9,  4.9]]))




```python
# 语法：X,Y = numpy.meshgrid(x, y)
# 输入的x，y，就是网格点的横纵坐标列向量（非矩阵）
# 输出的X，Y，就是坐标矩阵
z = np.sqrt(xs ** 2 + ys ** 2)
```




    array([[7.07106781, 7.00071425, 6.93108938, ..., 6.86221539, 6.93108938,
            7.00071425],
           [7.00071425, 6.92964646, 6.85930026, ..., 6.78969808, 6.85930026,
            6.92964646],
           [6.93108938, 6.85930026, 6.7882251 , ..., 6.71788657, 6.7882251 ,
            6.85930026],
           ...,
           [6.86221539, 6.78969808, 6.71788657, ..., 6.64680374, 6.71788657,
            6.78969808],
           [6.93108938, 6.85930026, 6.7882251 , ..., 6.71788657, 6.7882251 ,
            6.85930026],
           [7.00071425, 6.92964646, 6.85930026, ..., 6.78969808, 6.85930026,
            6.92964646]])



### 条件逻辑表述为数组运算



```python
# numpy.where函数是三元表达式x if condition else y的向量化版本。假设我们有一个布尔数组和两个值数组：
xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])
yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])
cond = np.array([True, False, True, True, False])
```


```python
#当cond中的值为True时，选取xarr的值，否则从yarr中选取。列表推导式的写法应该如下所示
result = np.where(cond, xarr, yarr)
result
```




    array([1.1, 2.2, 1.3, 1.4, 2.5])




```python
# np.where的第二个和第三个参数不必是数组，它们都可以是标量值。在数据分析工作中，where通常用于根据另一个数组而产生一个新的数组
In [172]: arr = np.random.randn(4, 4)

In [173]: arr
Out[173]: 
array([[-0.5031, -0.6223, -0.9212, -0.7262],
       [ 0.2229,  0.0513, -1.1577,  0.8167],
       [ 0.4336,  1.0107,  1.8249, -0.9975],
       [ 0.8506, -0.1316,  0.9124,  0.1882]])

In [174]: arr > 0
Out[174]: 
array([[False, False, False, False],
       [ True,  True, False,  True],
       [ True,  True,  True, False],
       [ True, False,  True,  True]], dtype=bool)

In [175]: np.where(arr > 0, 2, -2)
Out[175]: 
array([[-2, -2, -2, -2],
       [ 2,  2, -2,  2],
       [ 2,  2,  2, -2],
       [ 2, -2,  2,  2]])
# 好家伙，真挺好用的
```


```python
使用np.where，可以将标量和数组结合起来。例如，我可用常数 2 替换arr中所有正的值：
In [176]: np.where(arr > 0, 2, arr) # set only positive values to 2
Out[176]: 
array([[-0.5031, -0.6223, -0.9212, -0.7262],
       [ 2.    ,  2.    , -1.1577,  2.    ],
       [ 2.    ,  2.    ,  2.    , -0.9975],
       [ 2.    , -0.1316,  2.    ,  2.    ]])
```

### 数学和统计方法
可以通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算。sum、mean以及标准差std等聚合计算（aggregation，通常叫做约简（reduction））既可以当做数组的实例方法调用，也可以当做顶级 NumPy 函数使用


```python
arr = np.random.randn(5, 4)
arr.mean() # 取均值
#等价于
np.mean(arr)
```




    -0.07160190779285154




```python
# mean和sum这类的函数可以接受一个axis选项参数，用于计算该轴向上的统计值，最终结果是一个少一维的数组
arr.mean(axis=1)
arr.sum(axis=0)
# arr.mean(1)是“计算行的平均值”，arr.sum(0)是“计算每列的和”。
```




    array([ 2.30840884, -1.54768734, -0.36700651, -1.82575314])




```python
# 其他如cumsum和cumprod之类的方法则不聚合，而是产生一个由中间结果组成的数组
In [184]: arr = np.array([0, 1, 2, 3, 4, 5, 6, 7])

In [185]: arr.cumsum()
Out[185]: array([ 0,  1,  3,  6, 10, 15, 21, 28])
# 在多维数组中，累加函数（如cumsum）返回的是同样大小的数组，但是会根据每个低维的切片沿着标记轴计算部分聚类：
arr = np.array([[0, 1, 2], [3, 4, 5], [6, 7, 8]])
In [188]: arr.cumsum(axis=0)
Out[188]: 
array([[ 0,  1,  2],
       [ 3,  5,  7],
       [ 9, 12, 15]])

In [189]: arr.cumprod(axis=1)
Out[189]: 
array([[  0,   0,   0],
       [  3,  12,  60],
       [  6,  42, 336]])
# std,var分别为标准差和方差，自由度可调
```

### 用于布尔型数组的方法
在上面这些方法中，布尔值会被强制转换为 1（True）和 0（False）。因此，sum经常被用来对布尔型数组中的True值计数



```python
arr = np.random.randn(10)
arr
```




    array([ 0.94596544, -0.78878991,  0.99085394,  0.21433405, -1.88515215,
            0.07353868, -0.62621241,  0.34457747,  0.17650564, -0.84411828])




```python
(arr > 0).sum()
```




    6




```python
# 另外还有两个方法any和all，它们对布尔型数组非常有用。
# any用于测试数组中是否存在一个或多个True，而all则检查数组中所有值是否都是True
bools = np.array([False, False, True, False])
bools.any()
bools.all()
```




    False



### 排序
跟 Python 内置的列表类型一样，NumPy 数组也可以通过sort方法就地排序


```python
arr = np.random.randn(6)
arr.sort()
arr
```




    array([-2.1943807 , -0.57946737, -0.37496308, -0.35137108, -0.16260878,
            0.77884612])




```python
# 多维数组可以在任何一个轴向上进行排序，只需将轴编号传给sort即可
In [199]: arr = np.random.randn(5, 3)

In [200]: arr
Out[200]: 
array([[ 0.6033,  1.2636, -0.2555],
       [-0.4457,  0.4684, -0.9616],
       [-1.8245,  0.6254,  1.0229],
       [ 1.1074,  0.0909, -0.3501],
       [ 0.218 , -0.8948, -1.7415]])

In [201]: arr.sort(1)

In [202]: arr
Out[202]: 
array([[-0.2555,  0.6033,  1.2636],
       [-0.9616, -0.4457,  0.4684],
       [-1.8245,  0.6254,  1.0229],
       [-0.3501,  0.0909,  1.1074],
       [-1.7415, -0.8948,  0.218 ]])
```


```python
# 顶级方法np.sort返回的是数组的已排序副本，而就地排序则会修改数组本身。
# 计算数组分位数最简单的办法是对其进行排序，然后选取特定位置的值
In [203]: large_arr = np.random.randn(1000)

In [204]: large_arr.sort()

In [205]: large_arr[int(0.05 * len(large_arr))] # 5% quantile
Out[205]: -1.5311513550102103
```

### 唯一化以及其它的集合逻辑
#### NumPy 提供了一些针对一维ndarray的基本集合运算。最常用的可能要数np.unique了，它用于找出数组中的唯一值并返回已排序的结果



```python
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
np.unique(names)#同时是排好序的 等价于sorted(set)
```




    array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'], dtype='<U4')




```python
# 另一个函数np.in1d用于测试一个数组中的值在另一个数组中的成员资格，返回一个布尔型数组
In [211]: values = np.array([6, 0, 0, 3, 2, 5, 6])

In [212]: np.in1d(values, [2, 3, 6])
Out[212]: array([ True, False, False,  True,  True, False,  True], dtype=bool)
```

#### 用于数组的文件输入输出
NumPy 能够读写磁盘上的文本数据或二进制数据。这一小节只讨论 NumPy 的内置二进制格式，因为更多的用户会使用 pandas 或其它工具加载文本或表格数据
np.save和np.load是读写磁盘数组数据的两个主要函数。默认情况下，数组是以未压缩的原始二进制格式保存在扩展名为.npy的文件中的


```python
In [213]: arr = np.arange(10)

In [214]: np.save('some_array', arr)
# 如果文件路径末尾没有扩展名.npy，则该扩展名会被自动加上。然后就可以通过np.load读取磁盘上的数组
In [215]: np.load('some_array.npy')
Out[215]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
# 通过np.savez可以将多个数组保存到一个未压缩文件中，将数组以关键字参数的形式传入即可
np.savez('array_archive.npz', a=arr, b=arr)
# 加载.npz文件时，你会得到一个类似字典的对象，该对象会对各个数组进行延迟加载
In [217]: arch = np.load('array_archive.npz')

In [218]: arch['b']
Out[218]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
# 如果要将数据压缩，可以使用numpy.savez_compressed
np.savez_compressed('arrays_compressed.npz', a=arr, b=arr)
```


```python

```
